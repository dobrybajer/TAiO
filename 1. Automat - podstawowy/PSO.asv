function [b_mtx, be_proc] = PSO(s_cnt, d_cnt, mtx)

% Inicjalizacja œrodowiska:
pCount = 5; % Liczba cz¹stek
maxIterations = 1000; % Liczba maksymalnych iteracji, jak¹ wykona funkcja
gBestValue = 2; % Globalne minimum pocz¹tkowe
pBestValue=ones(pCount,1);
l_bnd=0;
u_bnd=1;
c1=2;
c2=2;
% Inicjalizacja cz¹stek,  do ka¿dej cz¹stki przypisujemy:
% - pocz¹tkow¹ pozycjê
% - najlepsza pozycja (to samo co wy¿ej) lub 'gBest' jeœli gBest mniejsze
% - pocz¹tkow¹ prêdkoœæ

vu_bnd=abs(u_bnd-l_bnd);
vl_bnd=-vu_bnd;


pBest = zeros(s_cnt, s_cnt, d_cnt, pCount);
for i = 1:pCount
    X = l_bnd +(u_bnd-l_bnd).*rand(s_cnt, s_cnt, d_cnt, i);
    pBest(:,:,:,i)=X(:,:,:,i);
    V = vl_bnd +(vu_bnd-vl_bnd).*rand(s_cnt, s_cnt, d_cnt, i);
    g_mtx=AutomataRecreator(X(:,:,:,i));
    [~, pBestErrorPerc]=ErrorFunction2(mtx,g_mtx);
    if(pBestErrorPerc<gBestValue)
       gBestValue=pBestErrorPerc;
       gBest=X(:,:,:,i);
       pBestValue(i,1)=pBestErrorPerc;
    end
end

% G³ówna pêtla funkcji. Wykonuje siê nie wiêcej ni¿ 'maxIter' razy, ale
% tak¿e mo¿e zostaæ zakoñczona wczeœniej, jeœli spe³nione jest kryterium
% znalezienia wystarczaj¹co dobrego rozwi¹zania (tzn. ¿e kolejne zmiany s¹
% niewiele polepszaj¹ce rozwi¹zanie)
iteration = 1;
while iteration < maxIterations
    for i = 1:pCount
        V(:,:,:,i)=V(:,:,:,i)+c1.*rand().*(pBest(:,:,:,i)-X(:,:,:,i))+c2.*rand().*(gBest-X(:,:,:,i));
        X(:,:,:,i)=X(:,:,:,i)+V(:,:,:,i);
        
        g_mtx=AutomataRecreator(X(:,:,:,i));
        [~, pBestErrorPerc]=ErrorFunction2(mtx,g_mtx);
        if(pBestErrorPerc<pBestValue(i,1))
           pBestValue(i,1)=pBestErrorPerc;
           pBest(:,:,:,i)=X(:,:,:,i);
           if(pBestErrorPerc<gBestValue)
               gBestValue=pBestErrorPerc;
               gBest=X(:,:,:,i);
           end
        end
    end
    iteration=iteration+1;
end
b_mtx=AutomataRecreator(gBest);
be_proc=gBestValue;
end

